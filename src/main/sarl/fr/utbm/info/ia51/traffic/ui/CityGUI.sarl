package fr.utbm.info.ia51.traffic.ui

import fr.utbm.info.ia51.framework.math.Point2i
import fr.utbm.info.ia51.traffic.environment.^agent.EnvironmentEvent
import fr.utbm.info.ia51.traffic.environment.^agent.EnvironmentListener
import fr.utbm.info.ia51.traffic.environment.city.*
import java.awt.BorderLayout
import java.awt.Color
import java.awt.Dimension
import java.awt.Graphics
import java.awt.Graphics2D
import java.awt.^event.KeyEvent
import java.awt.^event.KeyListener
import java.util.Map
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import javax.imageio.ImageIO
import javax.swing.BoxLayout
import javax.swing.ImageIcon
import javax.swing.JButton
import javax.swing.JFrame
import javax.swing.JOptionPane
import javax.swing.JPanel
import javax.swing.JScrollPane
import org.arakhne.afc.vmutil.Resources
import org.arakhne.afc.vmutil.locale.Locale

import static java.lang.Math.*

/**
 * Swing UI for the PacMan game. 
 */
class CityGUI extends JFrame implements KeyListener, EnvironmentListener {

	/** Width in pixels of a cell.
	 */
	public static val CELL_WIDTH = 20

	/** Height in pixels of a cell.
	 */
	public static val CELL_HEIGHT = 20

	/** Demi-width in pixels of a cell.
	 */
	public static val DEMI_CELL_WIDTH = CELL_WIDTH / 2

	/** Demi-height in pixels of a cell.
	 */
	public static val DEMI_CELL_HEIGHT = CELL_HEIGHT / 2

	val isInit = new AtomicBoolean

	val gridPanel : GridPanel
	
	val startButton : JButton 
	
	val waitingDuration : long 
	

	/**
	 * @param waitingDuration - the duration of sleeping before giving the hand to the simulator back.
	 */
	new (waitingDuration : long) {
		this.waitingDuration = waitingDuration
		this.title = Locale::getString("TrafficSimulation")
		var pacmanIcon = Resources::getResource(typeof(CityGUI), "pacman.png")
		this.iconImage = ImageIO::read(pacmanIcon)
		var iconURL = Resources::getResource(this.class, "play.png")
		this.startButton = new JButton(new ImageIcon(iconURL))
		this.startButton.toolTipText = Locale::getString("START")
		this.startButton.enabled = false
		this.startButton.addActionListener [
			var ctrl = CityGUI.this.controller
			if (ctrl !== null && !ctrl.started) {
				CityGUI.this.startButton.enabled = false
				ctrl.startSimulation
			}
		]
		var topPanel = new JPanel
		topPanel.layout = new BoxLayout(topPanel, BoxLayout::X_AXIS)
		topPanel.add(this.startButton)
		this.gridPanel = new GridPanel
		this.gridPanel.focusable = true
		this.gridPanel.addKeyListener(this)
		var sc = new JScrollPane(this.gridPanel)
		this.contentPane.layout = new BorderLayout
		this.contentPane.add(BorderLayout::NORTH, topPanel)
		this.contentPane.add(BorderLayout::CENTER, sc)
		this.preferredSize = new Dimension(600,600)
		this.defaultCloseOperation = JFrame::EXIT_ON_CLOSE
		pack
	}


	def bindController(controller : Controller) : void {
		synchronized(this) {
			this.controller = controller
			this.startButton.enabled = !this.controller.started
		}
	}

	def unbindController(controller : Controller) : void {
		synchronized(this) {
			this.startButton.enabled = false
			this.controller = null
		}
	}

	def environmentChanged(^event : EnvironmentEvent) : void {
		if (!isInit.get) {
			this.isInit.set(true)
			this.gridPanel.preferredSize = new Dimension(
					CELL_WIDTH * ^event.width,
					CELL_HEIGHT * ^event.height)
			revalidate
			pack
			this.visible = true
			this.gridPanel.requestFocus
		}
		this.gridPanel.setObjects(^event.time, ^event.objects)
		if (this.waitingDuration > 0) {
			try {
				Thread::sleep(this.waitingDuration)
			} catch (e : InterruptedException) {
				throw new RuntimeException(e)
			}
		}
	}


	/**
	 * Swing panel that is displaying the environment state.
	 * 
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 */
	@SuppressWarnings("unreachable_instance_of")
	private static class GridPanel extends JPanel {

		var objects : Map<Point2i, CityObject> 
		var time = new AtomicInteger

		new {
			this.background = Color::BLACK
		}

		def setObjects(time : int, objects : Map<Point2i, CityObject>) {
			synchronized(this.treeLock) {
				this.time.set(time)
				this.objects = objects
				repaint
			}
		}

		def paint(g : Graphics) {
			super.paint(g)

			var px : int
			var py : int
			var g2d = g as Graphics2D

			var isEvenTime = (this.time.get % 2) == 0

			if (this.objects !== null) {
				for (entry : this.objects.entrySet) {
					var pos = entry.key
					var obj = entry.value
					px = CELL_WIDTH * pos.x
					py = CELL_HEIGHT * pos.y
					if (obj instanceof WallObject) {
						g2d.color = Color::BLUE
						g2d.fillRect(px, py, CELL_WIDTH, CELL_HEIGHT)
					}
					else if (obj instanceof DriverBody) {
							g2d.color = Color::YELLOW
						if (isEvenTime) {
							g2d.fillArc(
									px + 1, py + 1, CELL_WIDTH - 2, CELL_HEIGHT - 2,
									45, 270)
						}
						else {
							g2d.fillArc(
									px + 1, py + 1, CELL_WIDTH - 2, CELL_HEIGHT - 2,
									5, 350)
						}
						g2d.color = this.background
						var eyex = px + DEMI_CELL_WIDTH - 2
						var eyey = py + DEMI_CELL_HEIGHT / 2 - 2
						if (!isEvenTime) eyex++
						g2d.fillOval(eyex, eyey, 4, 4)
					}
					else if (obj instanceof GovBody) {
						g2d.color = Color::WHITE

						g2d.fillArc(
								px + 3, py + 1, CELL_WIDTH - 6, CELL_HEIGHT - 2,
								0, 180)

						var up = py + DEMI_CELL_HEIGHT
						var bottom1 = py + CELL_HEIGHT - 2
						var bottom2 = bottom1 - 4
						var lleft = px + 3
						var left = px + DEMI_CELL_WIDTH / 2
						var middle = px + DEMI_CELL_WIDTH
						var right = px + DEMI_CELL_WIDTH + DEMI_CELL_WIDTH / 2
						var rright = px + CELL_WIDTH - 3
						if (!isEvenTime) {
							left--
							middle -= 2
							bottom2 += 2
						}
						var xx : int[] = #{
								lleft,
								lleft,
								left,
								middle,
								right,
								rright,
								rright
						}
						var yy  : int[] = #{
								up,
								bottom1,
								bottom2,
								bottom1,
								bottom2,
								bottom1,
								up
						}
						g2d.fillPolygon(xx, yy, min(xx.length,yy.length))

						var dx = 0
						var dy = 0

						var eyex = px + DEMI_CELL_WIDTH - 5 + dx
						var eyey = py + DEMI_CELL_HEIGHT / 2 + dy
						g2d.color = this.background
						g2d.fillOval(eyex, eyey, 5, 5)
						g2d.color = Color.WHITE

						eyex = px + DEMI_CELL_WIDTH + 2 + dx
						g2d.color = this.background
						g2d.fillOval(eyex, eyey, 5, 5)

					} 
					else {
							g2d.color = Color::WHITE
							if (isEvenTime) {
								g2d.fillOval(px + DEMI_CELL_WIDTH - 2, py + DEMI_CELL_HEIGHT - 2, 4, 4)
							}
							else {
								g2d.fillOval(px + DEMI_CELL_WIDTH - 3, py + DEMI_CELL_HEIGHT - 3, 6, 6)
							}
						}
					}

				}
			}
		}
	
	
}


