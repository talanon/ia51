package fr.utbm.info.ia51.traffic.environment.city

import fr.utbm.info.ia51.framework.math.Point2i
import java.lang.reflect.Array
import java.util.ArrayList
import java.util.Collection
import java.util.Collections
import java.util.List
import java.util.Random
import java.util.TreeMap
import java.util.UUID

/**
 * Define the city.
 */
class City {

	/** Max number of super pills in the world.
	 */
	static val MAX_SUPER_PILLS = 5

	/** Matrix of the objects.
	 */
	val grid : EnvrionmentObject[][] 

	val bodies = new TreeMap<UUID, AgentBody>

	/** Width of the world.
	 */
	val width : int 

	/** Height of the world.
	 */
	val height : int 

	/** Random generator.
	 */
	val random = new Random

	/**
	 * @param width is the width of the world.
	 * @param height is the height of the world.
	 */
	new (width : int, height : int) {
		this.width = width
		this.height = height
		this.grid = Array::newInstance(EnvrionmentObject, width, height) as EnvrionmentObject[][]

		buildWorld(this.width, this.height);
	}

	/** Build the maze and fill the spaces with pills.
	 * 
	 * @param width width of the maze.
	 * @param height height of the maze.
	 */
	private def buildWorld(width : int, height : int) : void {
		//buildMaze_recursiveAlgorithm(0, width, 0, height);
		buildCity
	}

	/** Build the maze with the Prim's algorithm.
	 */
	private def buildCity : void {
		
		for (var i = 0; i < this.width; i++) {
			for (var j = 0; j < this.height; j++) {
				//this.grid.get(i).set(j, new WallObject(i, j, this))
			}
		}
	}

	/** Replies if the cell at the given coordinates can receive a body.
	 * 
	 * @param x
	 * @param y
	 * @return <code>true</code> if the cell is empty or has a pickable object; <code>false</code>
	 * otherwise.
	 */
	@Pure
	synchronized def canMoveInside(x : int, y : int) : boolean {
		x >= 0 && y >= 0 && x < this.width && y < this.height
		&& (this.grid.get(x).get(y) === null)
	}

	/** Create a body of the given type.
	 *
	 * @param bodyType the type of the body.
	 * @param agentId the identifier of the agent that will be linked to the body.
	 * @param perceptionDistance the distance of perception.
	 * @return the body.
	 * @throws Exception if it is impossible to retrieve the body constructor or to create the instance. 
	 */
	def createBody(bodyType : Class<T>, agentId : UUID, perceptionDistance : int) : T with T extends AgentBody {
		var x = this.random.nextInt(width)
		var y = this.random.nextInt(height)
		while (!canMoveInside(x, y)) {
			x = this.random.nextInt(width)
			y = this.random.nextInt(height)
		}

		var id = agentId
		if (id === null) {
			id = UUID::randomUUID
		}

		var cons = bodyType.getDeclaredConstructor(typeof(int), typeof(int), typeof(Maze), typeof(UUID), typeof(int))
		var body = cons.newInstance(x, y, this, id, perceptionDistance)

		this.grid.get(x).set(y, body)
		this.bodies.put(id, body)

		return body
	}

	/** Replies the number of bodies in the maze.
	 * 
	 * @return the number of bodies.
	 */
	@Pure
	def getBodyCount : int {
		this.bodies.size
	}

	/** Replies the object at the given position.
	 * 
	 * @param x
	 * @param y
	 * @return the object or <code>null</code>.
	 */
	@Pure
	def getObjectAt(x : int, y : int) : CityObject {
		if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
			return this.grid.get(x).get(y)
		}
		return new WallObject(x, y, this)
	}

	/** Set the object at the given position.
	 * 
	 * @param x
	 * @param y
	 * @param obj the object to put at the position
	 * @return the object in the cell before the change.
	 */
	def setObjectAt(x : int, y : int, obj : CityObject) : CityObject {
		if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
			var old = this.grid.get(x).get(y)
			this.grid.get(x).set(y, obj)
			if (obj !== null) {
				obj.setPosition(x, y)
			}
			return old
		}
		return null
	}

	/** Set the object at the given position.
	 * 
	 * @param position
	 * @param obj the object to put at the position
	 * @return the object in the cell before the change.
	 */
	def setObjectAt(position : Point2i, obj : CityObject) : CityObject {
		setObjectAt(position.x, position.y, obj)
	}

	/** Replies the agent bodies.
	 *
	 * @return the agent bodies.
	 */
	def getAgentBodies : Collection<AgentBody> {
		Collections.unmodifiableMap(this.bodies).values
	}

	/** Replies the agent body.
	 *
	 * @param id
	 * @return the body.
	 */
	@Pure
	def getAgentBody(id : UUID) : AgentBody {
		this.bodies.get(id)
	}
	
}
